<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
Clock distribution implementation</title>
</head>
<body background="grey.jpg">
<h1 align=center>
<A NAME="6"></A>Chapter 6 : Clock distribution implementation</h1>



<p>
This chapter describes the implementation of the distribution of a
precise, accurate clock to Pandora systems over both the CFR and ATM
switch networks. It is divided into five sections, covering the
logical clock model implementation (used in many places inside
Pandora), the time server implementation, the network subsystem's time
client required for both the CFR and ATM switch networks, and the
extensions to the Pandora box software required to distribute time
inside a Pandora box. It uses the logical clock models specified in
section <A HREF="high_precision_clock_distribution.html#4.5.4">4.5.4</A> and examined in section
<A HREF="experimentation_for_global_clocks.html#5.3">5.3</A>, the research into message transmission
times described in sections <A HREF="experimentation_for_global_clocks.html#5.1">5.1</A> and
<A HREF="experimentation_for_global_clocks.html#5.2">5.2</A>, and enhances the Pandora software described in
chapters <A HREF="networking_for_pandora_boxes.html#2">2</A> and <A HREF="pandora_network_software_implementation.html#3">3</A>.

<p>
<A NAME="6.1"></A><h3>
6.1 Logical clock model implementation
</h3>
<p>


<p>


<p>
As described in section <A HREF="high_precision_clock_distribution.html#4.5.4">4.5.4</A>, an initial
attempt at implementing a logical clock model was performed before
research into this area was carried out. This clock model was
rudimentary, using 32-bit integers to describe phase and frequency
errors of the derived clock with respect to the clock messages
received as input to microsecond precision. The second implementation
for transputer systems was the enhanced fixed point Fuzzball logical
clock. This implementation was performed by converting the
experimental implementation (see section
<A HREF="experimentation_for_global_clocks.html#5.3">5.3</A>) from C into occam.

<p>
The logical clock model implementation consists of three processes
which share some state. The first of these takes clock messages and
updates the clock correction values in the shared state. The second
process updates the clock difference value, which contains information
relating to the difference between the local clock value and the
derived global clock value. The third process waits for requests from
timestamping systems, reads the derived global clock value using the
local clock value and the clock difference value from the shared
state, and presents this as the response.

<p>
All three processes run at high priority, so that access to the shared
state may occur atomically. The processes in more detail are:

<p>
<UL>


<p>
<LI>Clock correction calculation process

<p>
This process waits for messages, which consist of four integers, on
its input channel. The four integer values are the global clock value in
seconds and microseconds since midnight January 6th 1980, the message
transit time estimate, and the local clock value corresponding to the
arrival of the message in the processor.

<p>
The clock message filtering occurs here, as well as calculation of
frequency and phase errors of the derived global clock generated by
the logical clock model.

<p>
For debugging and informational purposes the frequency error, phase
error, compliance, frequency error divisor, and filter values can be
displayed on the 16-character LED display attached to the slave
transputer of a Pandora network card, if the logical clock model
implementation is running on a network card.

<p>
</LI>
<LI>Clock difference adjustment process

<p>
The <I> clock difference adjustment</I> process waits on a timer between
adjusting the clock difference value in the shared state. The number
of microseconds by which the clock difference value needs to be
adjusted by in one second is calculated; from this the time interval
required between single microsecond adjustments of the clock
difference value is calculated. If this time interval is too small
(less than a millisecond), perhaps because the phase error is large,
or the local clock runs much too fast or too slow, so introducing a
large frequency error, then a time interval of a millisecond is used
and each time the clock difference value is adjusted by the
appropriate number of microseconds this interval corresponds to.

<p>
In the enhanced fixed point Fuzzball logical clock model, the <I> clock
difference adjustment</I> process also implements the adjustments to the
phase error and clock correction parameters, which occur at 0.1
second intervals. This in turn leads to a recalculation of the above
microsecond adjustment intervals and adjustment values.

<p>
</LI>
<LI>Clock reading process

<p>
The <I> clock reading</I> process simply waits for a message, the
contents of which are ignored. When one is received the local clock
value is read. From this value and the clock difference value the global clock value
is calculated according to the logical clock model. The result, in
either seconds and microseconds, or as a 64-bit microsecond value, is
sent on its outward channel as a response. (In Pandora systems the
data source timestamps use the bottom 32 bits of the 64-bit
microsecond value).

<p>
</LI>
</UL>


<p>
<A NAME="6.2"></A><h3>
6.2 Time server implementation
</h3>
<p>


<p>
This section describes the implementation of the time server itself.
The time server uses the Pandora network cards with an additional
serial card designed specifically for the time server to access the
Navstar GPS receiver unit.

<p>
<A NAME="6.2.1"></A><h4>
6.2.1 Navstar GPS interface
</h4>
<p>


<p>
The serial card contains a T222 transputer to control a UART, through
which it communicates using RS422 to a Navstar GPS receiver unit. The
GPS receiver can supply positioning, timing and operational
information, and can be told to operate in suitable modes to optimise
the accuracy of its timing information. It also provides a single
open-collector output which is asserted and then deasserted
synchronised with the receiver's derived GPS clock. This signal can
interrupt the T222 transputer, as can the UART if it needs
servicing.

<p>
The software for the T222 in the serial card consists of four parts.
Firstly it has a high priority interrupt handling routine, which reads
the T222 internal clock as soon as it wakes up. The interrupt source
is then serviced. If the UART has received a byte then the interrupt
alerts the second process, which handles the UART. This runs at low
priority, so as not to effect the timing of the interrupt handler. It
inserts bytes into and extracts bytes from the UART's FIFOs. Any bytes
extracted are built into messages, which are then sent to the third
process, which decodes the messages. The fourth process uses a timer to
generate regular requests to the GPS receiver unit for the time, with
an interval of 1.25 seconds between requests. The requests must go
through the UART handler, which manages a queue of bytes for the
UART's transmit FIFO.

<p>
Accurate time information is transmitted from the T222 to the Pandora
network card using a 20 Mbps INMOS OS-link. This occurs when the
message handler decodes a time message from the GPS receiver unit. The
time message contains a time in seconds since midnight, January 6th
1980. The accuracy is achieved using the microsecond timer of the
T222, and subtracting the time between the GPS-synchronised interrupt
and the message being transmitted over the INMOS OS-link. This
difference is equal to the T222's ``microseconds'' since the last GPS
second boundary, the time specified in the message. The T222's clock
drift must be accounted for by the Pandora network card. To help
achieve this the same oscillator output is used to drive the serial
card's T222 transputer and the Pandora network card's transputers.

<p>
<A NAME="6.2.2"></A><h4>
6.2.2 Network card software
</h4>
<p>


<p>
The software on the Pandora network card divides into three parts:

<p>
<UL>


<p>
<LI>Serial card interface

<p>
The serial card interface takes messages from the T222 transputer,
records the time of their arrival, and forwards them to the logical
clock model. Its job is similar to the low levels of the clock message
reception software in clients of the time server. The clock messages
passed to the logical clock model contain the global clock value in
seconds. The clock message distribution time is given as the number of
microseconds since the interrupt on the T222 transputer. This method
(compared to the alternative of specifying the global clock time in
seconds and microseconds) allows the standard logical clock model to
be used, as it can then adjust the message distribution time with the
clock drift of the processor, rather than assuming the microsecond
count is accurate.

<p>
</LI>
<LI>Logical clock model

<p>
The logical clock model implementation in the time server is similar
to that described above in section <A HREF="clock_distribution_implementation.html#6.1">6.1</A>, but
with the clock message filter turned off: in the time server the
message distribution times are considered to be accurate local clock
times (there is not, after all, a complicated message distribution
system like a network).

<p>
</LI>
<LI>Network interface

<p>
The network interface contains specific code for the network handled,
as well as standard MSNL connection management. The time server
maintains a SAP to which clients may connect. A client sends a request
for a time to the time server, which is timestamped appropriately (in
a network-specific fashion, see the following sections), filled
with the global time, timestamped again, and then returned to the client.

<p>
The time server is restricted in the number of clients it can support,
so that the probability of two clients sending requests simultaneously is
kept very small.

<p>
</LI>
</UL>


<p>
<A NAME="6.3"></A><h3>
6.3 Clock distribution over the CFR
</h3>
<p>


<p>
The global clock implementation using the CFR network requires that a
network card which wants the global time become a time client of the
CFR-based time server. It does this by making an MSNL connection to
the SAP that the time server maintains. It then sends single packet
requests to the time server at regular intervals. The time server
responds to each of these requests with two single-packet messages, as
suggested by <A HREF="experimentation_for_global_clocks.html#5.2.3.5">5.2.3.5</A>. Information from the timing
of those messages and the contents of them is passed to the logical
clock model of the time client. In detail the communication runs as
follows:

<p>
The time client transmits a single packet request to the time server,
and records the time that its CFR CMOS chip signals the successful
transmission of the packet (time <I> ClientTxed</I>).

<p>
The slave transputer of the time server is waiting for an interrupt
from its CFR CMOS chip. When the packet is received by the slave
transputer's ring interface the CFR CMOS chip will generate a packet
received interrupt. The local clock value of the interrupt is recorded
(time <I> ServerRxed</I>). The packet is then read in to the slave, and
if it is a time request message (rather than an MSNL PDU) the global
clock value is requested from its master transputer. When the global
clock value is received, the local clock value of the slave is
recorded (time <I> ServerGlobal</I>). A response packet is then transmitted
to the time client. The CFR CMOS chip then generates an interrupt to
mark the succesful transmission of this packet, and the local clock
value of this interrupt is also recorded (time <I> ServerTxed</I>). A
second response packet is then sent to the time client containing all
three local clock values and the global clock value previously
received from the master transputer.

<p>
The time client records the local clock value of the packet received
interrupt from its CFR CMOS chip for the first response packet (time
<I> ClientRxed</I>). When it receives the second response packet it
calculates an estimate for the message distribution time, and passes a
clock message containing this and the global clock value specified in
the second response packet to its logical clock model.

<p>
The message distribution time estimate is calculated in two stages.
Firstly, the offset between the clocks of the client and server are
calculated. If the time client is considered to be the data source,
and the time server the echo server, in the experiments described in
section <A HREF="experimentation_for_global_clocks.html#5.2">5.2</A>, then the timestamp values enumerated in
section <A HREF="experimentation_for_global_clocks.html#5.2.2.1">5.2.2.1</A> correspond
to those local clock values mentioned above as follows: <I>
ClientTxed</I>, timestamp 1; <I> ServerRxed</I>, timestamp 4; <I>
ServerTxed</I>, timestamp 5; <I> ClientRxed</I>, timestamp 8. Then the two
traces in the graph in figure
<A HREF="experimentation_for_global_clocks.html#Fig5.14">5.14</A> corresponds to the differences between <I>
ServerTxed</I> and <I> ClientRxed</I> (upper trace), and <I> ServerRxed</I>
and <I> ClientTxed</I> (lower trace). If these are averaged then the
result is a good estimate for the difference between the local clocks
of the time server and time client (accurate to approximately a ring
rotation time). If this value is subtracted from <I> ServerGlobal</I>
then the result is an estimate for the time client's local clock value at
the point the global clock value was received by the time server's
slave transputer (call it <I> ClientGlobal</I>). The message distribution
time estimate is then <I> ClientRxed</I> minus <I> ClientGlobal</I>.

<p>
Extra inaccuracies in the message distribution time estimate may be
incurred if the clock readings are inaccurate. This can occur if, for
example, the server is asked to serve more than one client's message
at one time, or the client does not respond to the CFR CMOS chip's
interrupts immediately as it is executing another high priority task.
The first case is eliminated by making the method unreliable --- that
is, there is no guarantee that a request to the server will generate a
response: in particular, the server will abandon all simultaneous
requests as it detects them. The second case can be paritally removed
if the client only sends requests to the time server when it is idle
for at least a small period of time, although packets might be
received from other transmitters, and thus disrupt the handling of the
server response packets, at the same time as the replies from the time
server.

<p>
<A NAME="6.4"></A><h3>
6.4 Clock distribution over the ATM switch network
</h3>
<p>


<p>


<p>
The ATM switch network time server and the time client operate in a
similar fashion to the CFR system. However, in the ATM switch network
system the time server only responds with a single cell message
containing the local clock values <I> ServerRxed</I>, <I> ServerGlobal</I>
and <I> ServerTxed</I> and the global clock value.

<p>
 The time client/time server system attempts to mimic the data source
and echo server system described in section <A HREF="experimentation_for_global_clocks.html#5.1">5.1</A>.
Transmission times for cells <I> ClientTxed</I> are the local clock
values of the time the cell is inserted into the transmit FIFOs.
Reception times for cells <I> ClientRxed</I> are the local clock values
at which the receive interrupt is detected.

<p>
The message distribution times are taken to be <I> ClientRxed</I> minus
<I> ClientTxed</I>, minus the time taken in the time server, which is
<I> ServerTxed</I> minus <I> ServerRxed</I>, plus the difference between
<I> ServerTxed</I> and <I> ServerGlobal</I>. This assumes the cell
transmission times from client to server equal that from server to
client, and that the ATM cell FIFOs are empty except for the timing
cells so that the local clock readings are accurate. As for the CFR
system, the accuracy is improved by detecting two clients
simultaneously attempting to access the server, and by the client only
requesting time messages when its receive and transmit FIFOs are
empty. The ATM switch network system is more prone to problems as the
FIFOs are much longer than for the CFR. However, the clock filter
suggested in section <A HREF="experimentation_for_global_clocks.html#5.1.2.6">5.1.2.6</A> will filter these
messages out if they are not too frequent. The ATM switch network
implementation attempts to only transmit requests when its FIFOs are
empty by monitoring its block transmit queue. If it is empty, then the
request is transmitted, else the requesting process backs off. After a
number of attempts the requirement for an empty queue is relaxed to a
small queue. This may relax even more if the transmit load is
constantly heavy, so that time requests are not completely stopped. If
the load occurs for only a short time then the filtering mechanism
will cut out requests during the loaded periods. If the load is
consistent then the filtering mechanism will adapt to those conditions.

<p>
<A NAME="6.5"></A><h3>
6.5 Distributing time inside Pandora
</h3>
<p>



<p>
The first stage of distributing the global time inside a Pandora
system is to distribute the global time to the Pandora box over the
network. The second stage is to take the global time from the network
card to the server card. Finally the server can distribute the time to
the other subsystems, which are not directly reachable from the
network card. This section describes the additions to the Pandora box
software which were implemented to perform the distribution in those
stages.

<p>
<A NAME="6.5.1"></A><h4>
6.5.1 Network card improvements
</h4>
<p>


<p>
The Pandora network card software, in both CFR T4 card and ATM switch
versions, had to be updated to include the time client software. This
is performed in the master transputer software with an extra debugging
application process, the <I> time manager</I>, the logical clock model
implementation, and additional commands and messages to let the
network card's host read the global clock value. The slave software
versions for the different networks needed to be changed to provide
the recording of the local clock values <I> ClientTxed</I> and <I>
ClientRxed</I> for clock distribution packets on reception and
transmission, for accurate message distribution time estimation. An
extra slave command was specified to read these values for the last
clock distribution packets. Also, so the slave can determine which
packets are clock distribution packets, extra slave commands were added
to inform it of the VCI's for reception and transmission of the clock
distribution packets.

<p>
Only small changes in the slave software were required to implement
the extra facilities required, as no extra processes were required.
The rest of this section describes the changes to the master
transputer software.

<p>
The <I> time manager</I> process is responsible for the following:

<p>
<UL>


<p>
<LI>MSNL clock distribution connection

<p>
The MSNL connection between the Pandora box and the time server must
be made by the client. In the case of the Pandora box, the <I> time
manager</I> process is responsible for making the connection when global
clock distribution is required, killing it if it is not required, and
recovering from any network events which kill the connection.

<p>
The MSNL address and SAP for the time server are set by a command to
the master transputer software, and are stored in shared memory. The
<I> time manager</I> will attempt to make a connection to the time
server if the specified address is not zero. If the connection fails
to make the <I> time manager</I> process will receive a timeout message
from the <I> connection management</I> process via the <I> debug
manager</I>. In this case it backs off for thirty seconds before
rereading the address and SAP and retrying. Once the connection has
been made the slave software is informed of the VCIs corresponding to
the connection for the recording of local clock values for
transmission and reception of time requests and responses.

<p>
If the connection is ever killed by the network or the time server
then the <I> time manager</I> process will attempt to remake the
connection after the thirty second backoff period.

<p>
At present the time connection is deemed to be always required, so the
<I> time manager</I> process never kills the connection itself. However, future
implementations may kill the connection once the compliance of the
logical clock model reaches a satisfactory level, indicating small
phase and frequency errors. The connection would then be remade after
a certain time to realign the logical clock model with the time
server.

<p>
</LI>
<LI>Time request generation

<p>
Once the connection to the time server has been made, clock
distribution requests are generated by the <I> time manager</I> at
regular intervals of approximately one second. These appear to the
system as normal buffers for transmission. If the <I> time manager</I>
detects the network transmission system is not idle it will delay
sending the message for a short time before retrying. If the system
does not become idle after a number of retries the request will be
generated anyway, as inaccurate time is better than no time at all.

<p>
</LI>
<LI>Time response reception handling

<p>
When a response to a time message is received by the <I> time
manager</I> the slave software is interrogated to find the local clock
values corresponding to the times of transmission and reception of the
time request message and response. From these the message distribution
time estimate is calculated according to the network type, and then
the logical clock model is given this and the global clock value from
the response.

<p>
</LI>
</UL>


<p>
In addition to the <I> time manager</I> process, the <I> buffer to
host</I> process needed to be enhanced to allow high accuracy time
messages to be sent to the host. When the <I> buffer to host</I> process receives a
time message, it starts to send the message to the host, reads the
global time from the logical clock model, then finishes the message to
the host with the global time value read. Using this system the host
is guaranteed to be ready to receive the global time value when it is
sent, as the buffer will block on outputting the start of the message
until the host is ready to read the whole message. The host must then
read its local clock value immediately after receiving the message
from the buffer process, to get an accurate value corresponding to the
global clock value in the message. The time messages are generated in
response to time request commands from the host.

<p>
<A NAME="6.5.2"></A><h4>
6.5.2 Server card improvements
</h4>
<p>


<p>
The software for the server card required changes to handle the
distribution of the global clock value to it from the network, and an
extra processes to run the logical clock model and to help distribute
its global clock values to the other subsystems.

<p>
The <I> network output process</I> in the server card software was
changed to send time request commands to the network subsystem at
regular intervals of approximately one second. The <I> network
source</I> process, which reads messages from the network, was changed to
read the server's local clock value after receiving any message from
the network. If the message is a time message, then the server's
logical clock model is sent a clock message with a fixed distribution
time estimate. When a time message is received a Pandora response
(section <A HREF="networking_for_pandora_boxes.html#2.1.2.4">2.1.2.4</A>)is also generated, which travels up
along the response path to just before it leaves the server
transputer.

<p>
At this point the response arrives at a new process, which passes on
most rerports unchanged, except for those with report types indicating
a time message. These reports are changed to include the global clock
value read from the logical clock model, and are then sent on. From
the server the responses reach the capture card (see figure
<A HREF="networking_for_pandora_boxes.html#Fig2.3">2.3</A>).

<p>
<A NAME="6.5.3"></A><h4>
6.5.3 Other subsystem improvements
</h4>
<p>


<p>
The next Pandora subsystem on the clock distribution path is the
capture card. This extracts global time messages from the incoming
response path, and passes them to the capture processor's logical
clock model. Further distribution of time messages is performed using
a dedicated channel to the audio subsystem. This is possible as the
INMOS OS-link from the capture transputer to the audio transputer is
normally only used in the audio to capture direction (for requests,
see figure <A HREF="networking_for_pandora_boxes.html#Fig2.3">2.3</A>),
and not from capture to audio. A new process sends messages down this
channel at regular intervals of approximately one second, containing
values read from the capture transputer's logical clock model.

<p>
The audio transputer takes the messages from the channel, records the
local clock time of their arrival, and then passes them to its logical
clock model. The audio subsystem could also forward them down a
dedicated channel to the video mixer subsystem, as the INMOS OS-link
from the audio transputer to the video mixer transputer is only used
for the response path, in the video mixer to audio direction. However,
in the experiments planned for the Pandora system the video mixer is a
data sink only, and so generates no timestamps and no results, and it is
therefore not necessary to distribute global time to it. 

<p>
<A NAME="6.5.4"></A><h4>
6.5.4 Summary of system changes
</h4>
<p>


<p>
The changes to the Pandora system provide for distribution of global
time to all the data sources in the Pandora box down a chain of
messages. At each link of the chain inaccuracy can be introduced due
to the time taken to transmit the distribution messages down the
links, which may not be estimated with accuracy, and the transmission
will not be free of jitter. The current system could be improved in both
respects, although the constant message distribution time estimates
used generate adequate results. It must be borne in mind that the data
generation processes which require the timestamps do not require
timestamps accurate to a microsecond, as the data they are
timestamping is made up of quite long samples.

<p>
Overall, the Pandora system was changed as little as possible to
implement the distribution of the global clock so as to maintain
confidence in the software. If the whole Pandora box software were to
be redesigned then a more accurate global clock distribution algorithm
would be implemented.

<p>
<p>
<center><A HREF="results_of_pandora_experiments.html">Chapter 7 : Results of Pandora Experiments</A>
</body></html>
